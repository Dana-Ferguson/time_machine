// Portions of this work are Copyright 2018 The Time Machine Authors. All rights reserved.
// Portions of this work are Copyright 2018 The Noda Time Authors. All rights reserved.
// Use of this source code is governed by the Apache License 2.0, as found in the LICENSE.txt file.

import 'dart:convert';
import 'package:meta/meta.dart';
import 'package:time_machine/src/time_machine_internal.dart';

// todo: revisit this summary
/// Implementation of the Um Al Qura calendar, using the tabular data in the BCL. This is fetched
/// on construction and cached - we just need to know the length of each month of each year, which is
/// cheap as the current implementation only covers 183 years.
@internal
class UmAlQuraYearMonthDayCalculator extends RegularYearMonthDayCalculator {
  static const int _averageDaysPer10Years = 3544;

  // These four members are generated by UmAlQuraYearMonthDayCalculatorTest.GenerateData.
  static const int _computedMinYear = 1318;
  static const int _computedMaxYear = 1500;
  static const int _computedDaysAtStartOfMinYear = -25448;
  // todo: can this be further compressed (seems like produced data would take twice as much space to store as the code)
  static const String _generatedData =
      'AAAF1A3SHaQdSBqUFSwKbBVqG1QXSBaSFSYKVhSuCWwVagtUGqoaVBSsCVwSugXYDaoNVAqqCVYStgV0'
      'CuoXZA7IDpIMqgVWCrYVtA2oHZIbJBpKFJoFWgraFtQWpBVKFJYJLhJuBWwK6hrUGqQVLBJaBLoJuhW0'
      'C6gbUhqkFVQJrBNsBugO0g6kDUoKlhVWCrQVqhukG0gakhUqCloUugq0FaoNVA0qClYUrglcEuwK2Baq'
      'FVQUqglaEroFtAuyG2QXSBaUFKoFagrqFtQXpBeIFxIVKgpaC1oW1A2oG5IbJBVMEqwFXAraBtQWqhVU'
      'EpoJOhK6BXQLagtUGqoVNBJcBNwKuhW0DagNSgqWFS4KnBVcC1gXUhskFkoMlhlWCrQWqg2kHUoclBUq'
      'CloVWgbYDrINpA0qCloUtgl0E3QHaBbSFqQVTAlsEtoF2A2yHWQaqBpUFKwJXBLaGtQWqBZSFSYKVhSu'
      'CmwVag1UHSYAAA==';

  //  ComputedDaysAtStartOfMinYear + (((1 - ComputedMinYear) / 10.0) * AverageDaysPer10Years).toInt();
  static const int _computedDaysAtStartOfYear1 = -492192;

  // Precomputed values for lengths of year and lengths of months, populated in the static constructor.
  // The number of days in each year, with array index 1 representing ComputedMinYear.
  static /*final*/ List<int> _yearLengths = _genNumbers() ?? _yearLengths;

  // A set of 12 bits for each year, indicating the months which are 30 days long instead of 29.
  // (Month 1 is set in bit 1, etc. Bit 0 and bits 13-15 are unused.)
  // Note: this is all int32 on VM/Flutter -- float64 on JS todo: optimize differently
  static /*final*/ List<int> /*ushort[]*/ _monthLengths = _genNumbers() ?? _monthLengths;

  // Number of days from ComputedMinYear on a per year basis.
  static /*final*/ List<int> _yearStartDays = _genNumbers() ?? _yearStartDays;

  // todo: is this too cheesy?
  static List<int>? _genNumbers() {
    // byte[] data = Convert.FromBase64String(GeneratedData);
    var data = base64.decode(_generatedData);

    _monthLengths = List<int>.generate(data.length ~/ 2,
      (int i) => /*(ushort)*/((data[i * 2] << 8) | (data[i * 2 + 1]))
    ); // new ushort[data.Length / 2];

    _yearLengths = List<int>.filled(_monthLengths.length, 0);
    _yearStartDays = List<int>.filled(_monthLengths.length, 0);

    // Populate arrays from index 1.
    int totalDays = 0;
    for (int year = 1; year < _yearLengths.length - 1; year++) {
      _yearStartDays[year] = _computedDaysAtStartOfMinYear + totalDays;
      int monthBits = _monthLengths[year];
      int yearLength = 29 * 12;
      for (int month = 1; month <= 12; month++) {
        yearLength += (monthBits >> month) & 1;
      }
      _yearLengths[year] = yearLength;
      totalDays += yearLength;
    }

    // Fill in the cache with dummy data for before/after the min/max year, pretending
    // that both of the 'extra' years were 354 days long.
    _yearStartDays[0] = _computedDaysAtStartOfMinYear - 354;
    _yearStartDays[_yearStartDays.length - 1] = _computedDaysAtStartOfMinYear + totalDays;
    _yearLengths[0] = 354;
    _yearLengths[_yearStartDays.length - 1] = 354;

    return null;
  }

  UmAlQuraYearMonthDayCalculator()
      : super(_computedMinYear, _computedMaxYear, 12, _averageDaysPer10Years, _computedDaysAtStartOfYear1);

  // No need to use the YearMonthDayCalculator cache, given that we've got the value in array already.
  @override int getStartOfYearInDays(int year) => _yearStartDays[year - _computedMinYear + 1];

  // [ExcludeFromCodeCoverage]
  @protected
  @override
  int calculateStartOfYearDays(int year) {
    // Only called from the base GetStartOfYearInDays implementation.
    throw UnimplementedError();
  }

  @protected
  @override
  int getDaysFromStartOfYearToStartOfMonth(int year, int month) {
    // While we could do something clever to find the Hamming distance on the masked value here,
    // it's considerably simpler just to iterate...
    int monthBits = _monthLengths[year - _computedMinYear + 1];
    int extraDays = 0;
    for (int i = 1; i < month; i++) {
      extraDays += (monthBits >> i) & 1;
    }
    return (month - 1) * 29 + extraDays;
  }

  @override int getDaysInMonth(int year, int month) {
    int monthBits = _monthLengths[year - _computedMinYear + 1];
    return 29 + ((monthBits >> month) & 1);
  }

  @override int getDaysInYear(int year) =>
  // Fine for one year either side of min/max.
  _yearLengths[year - _computedMinYear + 1];

  @override YearMonthDay getYearMonthDay(int year, int dayOfYear) {
    int daysLeft = dayOfYear;
    int monthBits = _monthLengths[year - _computedMinYear + 1];
    for (int month = 1; month <= 12; month++) {
      int monthLength = 29 + ((monthBits >> month) & 1);
      if (daysLeft <= monthLength) {
        return YearMonthDay(year, month, daysLeft);
      }
      daysLeft -= monthLength;
    }
    // This should throw...
    Preconditions.checkArgumentRange('dayOfYear', dayOfYear, 1, getDaysInYear(year));
    throw StateError("Bug in Noda Time: year $year has ${getDaysInYear(year)} days but $dayOfYear isn't valid");
  }

  @override
  bool isLeapYear(int year) => _yearLengths[year - _computedMinYear + 1] == 355;
}
